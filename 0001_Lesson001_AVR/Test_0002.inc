;**************************************
; ЗАДАЧА_0002
; Организация работы с семисегментным индикатором
; Поочередно выводим цифры с 0 по 9
; Для работы с индикатором используем таблицу соответствия цифр-коду
; Работа только с одним индикатором
;**************************************
; Для реализации данной задачи нам необходимо
; составить таблицу соответствия цифры - коду включения сегментов индикатора
; И счетчик указывающий какую цифру выводить следубщей.
; Для красивого вывода цифр надо предусмотреть задержку
; между загоранием каждой цифры.
;**************************************
work_indicator:
;-------------------------- Инициализация Порта ввода/вывода B

		ldi		r16, 0xFF	; Записываем число $FF в регистр r16
		out		DDRB, r16	; Записываем это число в DDRB
		ldi		r16, 0x00	; Записываем число $00 в регистр r16
		out		PORTB, r16	; Записываем то  же число в PORTB
; проинициализировали порт В на вывод и погасили все сегменты индикатора с общим катодом

;-------------------------- Инициализация Порта ввода/вывода D

		ldi		r16, 0xC0	; Записываем число $С0 или 0b11000000 в регистр r16
		out		DDRD, r16	; Записываем это число в DDRD
		ldi		r16, 0x00	; Записываем число $00 в регистр r16
		out		PORTD, r16	; Записываем то  же число в PORTD
; проинициализировали порт D для контроля индикатора(когда гореть и какой цифре из двух)
; в данном примере используем только одну цифру индикатора

;**************************************

	ldi r17,-1	;проинициализируем счетчик цифры на вывод
; теперь организуем бесконечный цикл для вывода всех цифр
work_ind:
	inc r17	
	cpi r17,10	; произведем сравнение нашего счетчика(закольцовывание 0..9)
	brne normal	; в случае не равенства перейти по метке normal
	clr r17
normal:
; проведем выбор кода для соответствующей цифры
	LDI ZH,High(2*TableIndicator)	; работаем с памятью программ(есть *2)
	LDI ZL,Low(2*TableIndicator)
	add ZL,r17	; организуем смещение относительно начального адресса
	clr r18	; адресс представлен двумя байтами, при арифметических операциях
			; необходимо помнить о переполнении и учитывать его
	adc ZH, r18
	lpm r18,Z	;загружаем значение в регистр r18,хранимое по адрессу Z

	cbi PORTD, PD7	; погасим индикатор, перед тем как высветим новый код
	out PORTB, r18	;выставляем необходимый код на порт В
; для того чтоб цифра отобразилась на индикаторе необходимо зажечь её
	sbi PORTD, PD7

	rcall DelayLong	; организуем задержку для фиксации данного кода на индикаторе

	rjmp work_ind	; переходим на начало цикла(вывод следующей цифры)
;**************************************

		;-------------------------- Подпрограммы

;**************************************
;формула данной подпрограммы задержки
;((3*R20+3)*R21+4)*R22+20)
;
; пару примеров
;	для 1000000 тактов   100 165  20
;	для 2000000 тактов	  45 161  90	
;	для  500000 тактов	 223 248   3
;	для 6000000 тактов	 135 173  85
;	для 8000000 тактов	  95 224 124
DelayLong:
	push r20
	push r21
	push r22

	ldi r22, 20
loopL2:
	ldi r21, 165
loopL1:
	ldi r20,100
loopL0:
	dec r20
	brne loopL0
	dec r21
	brne LoopL1
	nop
	dec r22
	brne LoopL2

	nop
	pop r22
	pop r21
	pop r20
	ret

;**************************************

.equ a = 1		; Bit 0 - a, вес разряда 1
.equ b = 2		; Bit 1 - b, вес разряда 2
.equ c = 4		; Bit 2 - c, вес разряда 4
.equ d = 8		; Bit 3 - d, вес разряда 8
.equ e = 16		; Bit 4 - e, вес разряда 16
.equ f = 32		; Bit 5 - f, вес разряда 32
.equ g = 64		; Bit 6 - g, вес разряда 64
.equ DP = 128	; Bit 7 - DP, вес разряда 128

.equ Num0 = a+b+c+d+e+f	; цифра 0
.equ Num1 = b+c			; цифра 1
.equ Num2 = a+b+d+e+g	; цифра 2
.equ Num3 = a+b+c+d+g	; цифра 3
.equ Num4 = b+c+f+g		; цифра 4
.equ Num5 = a+c+d+f+g	; цифра 5
.equ Num6 = a+c+d+e+f+g	; цифра 6
.equ Num7 = a+b+c		; цифра 7
.equ Num8 = a+b+c+d+e+f+g	; цифра 8
.equ Num9 = a+b+c+d+f+g; цифра 9

;**************************************
;Таблица констант для вывода цифр на семисегментный индикатор
; 0 1 2 3 4 5 6 7 8 9
TableIndicator:
.db Num0,Num1	;.db	0b00111111, 0b00000110
.db Num2,Num3	;.db	0b01011011, 0b01001111
.db Num4,Num5	;.db	0b01100110, 0b01101101
.db Num6,Num7	;.db	0b01111101, 0b00000111
.db Num8,Num9	;.db	0b01111111, 0b01101111
