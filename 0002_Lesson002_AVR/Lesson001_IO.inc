/*
;****************************************
;**
;**			START
;**		LESSON_001_IO
;**
;**
;****************************************
Подпрограмма формирования меанрдра
;	rjmp test_main
;********
Подпрограмма вывода на семисегментный индикатор цифр
;	rjmp work_indicator
;********
Подпрограмма формирования задержки программным способом
;	ldi r19,0
;	rcall delay
;********
Подпрограмма формирования задержки программным способом
;	rcall DelaySmall
;********
Подпрограмма работы с индикатором в динамическом режиме
;	rjmp work_indicator2
;********
Подпрограмма работы с BCD индикатором
;	rjmp work_indBCD
;********
Подпрограмма формирования световых эффектов
- бегущая точка
- и так далее
;	rjmp work_Color
;********
Подпрограмма работы с клавиатурой
;	rjmp work_Keyboard
;********
Подпрограмма опроса кнопок программным способом
;	rjmp work_Button
;********
Подпрограмма работы с кнопками по прерываниям
;	rjmp work_ButINT
;********
Подпрограмма работы с кнопками по прерываниями №2
;	rjmp work_ButINT01
;********
;****************************************
;**		
;**			END
;**		LESSON_001_IO
;**
;**
;****************************************
*/
;**************************************
; работа с кнопками по внешним прерываниям
; это не освобождает нас от борьбы с дребезгом
; а также определения нажатой кнопки
;
;!!!!!! ОБЯЗАТЕЛЬНО в векторе прерываний инициализировать
; переходы на метку EXT_INT0 с адрессом 0x001 и EXT_INT1  с адресом 0x002
work_ButINT01:
;-------------------------- Инициализация Порта ввода/вывода B

		ldi		r16, 0xFF	; Записываем число $FF в регистр r16
		out		DDRB, r16	; Записываем это число в DDRB
		ldi		r16, 0xF0	; Записываем число $F0 в регистр r16
		out		PORTB, r16	; Записываем то  же число в PORTB
; проинициализировали порт B на вывод 

;-------------------------- Инициализация Порта ввода/вывода D

		ldi		r16, 0x00	; Записываем число $00 в регистр r16
		out		DDRD, r16	; Записываем это число в DDRD
		ldi		r16, 0x00	; Записываем число $00 в регистр r16
		out		PORTD, r16	; Записываем то  же число в PORTD
; проинициализировали порт D на ввод 

; настроим обработку внешних прерываний по приходу фронта сигнала
		in r16, MCUCR
		ori r16,0x0f
		out MCUCR,r16

; разрешим наши внешние прерывания	
		in r16,GICR
		ori r16,(1<<INT0)|(1<<INT1)
		out GICR,r16


; преобразуем регистр для вывода
	mov tmp2,Flags
;	ldi tmp3,0x0F
;	eor tmp2,tmp3
; вывод на BCD индикатор
nop
nop
	out PORTB,tmp2

		sleep
		rjmp PC-5

;**************************************

;**************************************
; работа с кнопками по внешним прерываниям
; это не освобождает нас от борьбы с дребезгом
; а также определения нажатой кнопки
;
work_ButINT:
;-------------------------- Инициализация Порта ввода/вывода B

		ldi		r16, 0xFF	; Записываем число $FF в регистр r16
		out		DDRB, r16	; Записываем это число в DDRB
		ldi		r16, 0xF0	; Записываем число $F0 в регистр r16
		out		PORTB, r16	; Записываем то  же число в PORTB
; проинициализировали порт B на вывод 

;-------------------------- Инициализация Порта ввода/вывода D

		ldi		r16, 0x00	; Записываем число $00 в регистр r16
		out		DDRD, r16	; Записываем это число в DDRD
		ldi		r16, 0x00	; Записываем число $00 в регистр r16
		out		PORTD, r16	; Записываем то  же число в PORTD
; проинициализировали порт D на ввод 

; настроим обработку внешних прерываний по приходу фронта сигнала
		in r16, MCUCR
		ori r16,0x0f
		out MCUCR,r16

; разрешим наши внешние прерывания	
		in r16,GICR
		ori r16,(1<<INT0)|(1<<INT1)
		out GICR,r16

		sleep
		rjmp PC-1

;!!!!!! ОБЯЗАТЕЛЬНО в векторе прерываний инициализировать
; переходы на метку EXT_INT с адрессов 0x001 и 0x002
EXT_INT:
; включим светик на выводе РВ0
; для индикации вхождения на обработку прерывания только для тестов
	sbi PORTB,PB0

; организуем небольшую программную задержку перед чтением нажатой кнопки
	clr tmp2
	ldi cnt1,8
searchButINT:
	dec cnt1
	brne searchButINT
; если кнопка удерживалась малый промежуток времени
; то прерывание вызвано ошибочно
	in	tmp1,PIND 
	andi	tmp1,0x0C
	cpi tmp1,0x0C
	breq end_INT
; начинаем обрабатывать нажатую кнопку
; опросим ее 16 раз чтоб убедиться что нажата определенная кнопка
	ldi cnt1,16
find_butINT:
	mov tmp2,tmp1

	in	tmp1,PIND 
	andi	tmp1,0x0C

	cp tmp2,tmp1
	brne find_butINT

	dec cnt1
	brne find_butINT

; преобразуем регистр для вывода
	ldi tmp3,0x00
	eor tmp2,tmp3

	out PORTB,tmp2
end_INT:
; отметим что для выхода из обработки прерывания
; обязательно используется специальная команда reti
	reti

;**************************************
; работа с клавиатурой
; реализуем опрос кнопок программно
;
work_Button:
;-------------------------- Инициализация Порта ввода/вывода B

		ldi		r16, 0xFF	; Записываем число $FF в регистр r16
		out		DDRB, r16	; Записываем это число в DDRB
		ldi		r16, 0xF0	; Записываем число $F0 в регистр r16
		out		PORTB, r16	; Записываем то  же число в PORTB
; проинициализировали порт B на вывод 

;-------------------------- Инициализация Порта ввода/вывода D

		ldi		r16, 0x00	; Записываем число $00 в регистр r16
		out		DDRD, r16	; Записываем это число в DDRD
		ldi		r16, 0x00	; Записываем число $00 в регистр r16
		out		PORTD, r16	; Записываем то  же число в PORTD
; проинициализировали порт D на ввод 

searchBut:
	in	tmp1,PIND 
	andi	tmp1,0x0F
	cpi tmp1,0x0F
	breq searchBut
	
	clr tmp2
	ldi cnt1,16
find_but:
	mov tmp2,tmp1

	in	tmp1,PIND 
	andi	tmp1,0x0F

	cp tmp2,tmp1
	brne find_but

	dec cnt1
	brne find_but

; преобразуем регистр для вывода
	ldi tmp3,0x00
	eor tmp2,tmp3

	out PORTB,tmp2

	rjmp searchBut

;**************************************
; работа с клавиатурой
; реализуем динамический опрос клавиатуры
;
work_KeyBoard:
;-------------------------- Инициализация Порта ввода/вывода B

		ldi		r16, 0xFF	; Записываем число $FF в регистр r16
		out		DDRB, r16	; Записываем это число в DDRB
		ldi		r16, 0xF0	; Записываем число $F0 в регистр r16
		out		PORTB, r16	; Записываем то  же число в PORTB
; проинициализировали порт B на вывод 

;-------------------------- Инициализация Порта ввода/вывода D

		ldi		r16, 0x07	; Записываем число $07 в регистр r16
		out		DDRD, r16	; Записываем это число в DDRD
		ldi		r16, 0x00	; Записываем число $F0 в регистр r16
		out		PORTD, r16	; Записываем то  же число в PORTD
; проинициализировали порт D на вывод 0..2 и на ввод 3..7 
Start_Key:
; зажгем линии клавиатуры
	in	tmp1,PORTD 
	ori	tmp1,0x07
	out PORTD,tmp1
;считаем, нажата ли хоть одна клавиша
	in tmp1,PIND
	andi tmp1,0b01111000
	breq Start_Key; ждем нажатия кнопки
; для борьбы с дребезгом 
; будем считывать кнопки пока не считаем 16 раз одну и ту же комбинацию
	clr tmp2
	ldi cnt1,16
Line1:	
; смотрим линию 1 цифры 1 4 7 *
	ldi tmp3,0
	cbi PORTD,PD1
	cbi PORTD,PD2
; если нашли на линии 1 кнопку идем ее определять
	in tmp1,PIND
	andi tmp1,0b01111000
	breq Line2
	rjmp find_key
Line2:
; смотрим линию 2 цифры 2 5 8 0
	ldi tmp3,1
	cbi PORTD,PD0
	sbi PORTD,PD1
; если нашли на линии 2 кнопку идем ее определять
	in tmp1,PIND
	andi tmp1,0b01111000
	breq Line3
	rjmp find_key
Line3:
; смотрим линию 3 цифры 3 6 9 №
	ldi tmp3,2
	cbi PORTD,PD1
	sbi PORTD,PD2
; если нашли на линии 3 кнопку идем ее определять
	in tmp1,PIND
	andi tmp1,0b01111000
	breq Start_Key

find_key:
; идея такая что проверяя все линии
; находим их вес
; если вес в текущем и предыдущем цикле опроса 
; совпадает, то это та кнопка что нужна
; в противном случае у нас дребезг
;
; приоритет у самой последней линии 
; при нажатии нескольких кнопок
; определим ту что ниже находится
	mov tmp2,tmp1

	sbic PIND,PD3
	ldi tmp1,1
	sbic PIND,PD4
	ldi tmp1,4
	sbic PIND,PD5
	ldi tmp1,7
	sbic PIND,PD6
	ldi tmp1,10
	
	cp tmp2,tmp1
	brne find_key

	dec cnt1
	brne find_key

; суммируем состовляющие кода нашей кнопки
	add tmp2,tmp3
; преобразуем регистр для вывода
	ldi tmp3,0x0F
	eor tmp2,tmp3

	out PORTB, tmp2

	rjmp Start_Key
;**************************************

;**************************************
; работа с линейкой светодиодо
; реализуем несколько световых эффектов
; например
;C1	бегущая светик по кругу
;C2	бегущий светик из стороны в сторону
;C3	два последовательных светика
;C4	горит каждый второй
;
work_Color:
;-------------------------- Инициализация Порта ввода/вывода B

		ldi		r16, 0xFF	; Записываем число $FF в регистр r16
		out		DDRB, r16	; Записываем это число в DDRB
		ldi		r16, 0xF0	; Записываем число $F0 в регистр r16
		out		PORTB, r16	; Записываем то  же число в PORTB
; проинициализировали порт B на вывод 
; и погасили все светики с общим катодом(младшая тетрада)
; и с общим анодом (старшая тетрада)
work_C1_:
	ldi tmp1,0b00000001
	clr cnt1
work_C1:
;сбросим флаг переноса
	clc
;проверим надо ли при сдвиге внести значение переноса
	brtc PC+2
	sec
	clt
;проводим сдвиг
	rol tmp1
	brcc PC+2
;при необходимости запомним наличие переноса при последнем сдвиге
	set

	rcall Delay

;организуем паузу выполнения эффекта
	inc cnt1
	cpi cnt1,32
	breq work_C2_

;учитывая что у нас есть светодиоды
; как с общим анодом так и с общим катодом преобразуем выходной байт
	mov tmp2,tmp1
	ldi tmp3,0x0F
	eor tmp2,tmp3
	
	out PORTB,tmp2
	rjmp work_C1

work_C2_:
	ldi tmp1,0b00000001
	clr cnt1
work_C2:
;организуем проверку в какую сторону движемся
; для этого выставляем признак флаг Т
	cpi tmp1,0b10000000
	brne PC+2
	set
	cpi tmp1,0b00000001
	brne PC+2
	clt
	
;просмотрим в хранилище необходим ли нам бит переноса
	clc
	sbrc Flags,0
	sec
;организуем сдвиг
;смотрим флаг Т(направление)
	rol tmp1
	brtc PC+3
	ror tmp1
	ror tmp1
;запоминаем флаг переноса
	clr Flags
	brcc PC+2
	ldi Flags, 1	

	rcall Delay

	inc cnt1
	cpi cnt1,64
	breq work_C3_

	mov tmp2,tmp1
	ldi tmp3,0xF0
	eor tmp2,tmp3

	out PORTB,tmp2
	rjmp work_C2

work_C3_:
	ldi tmp1,0b00000011
	clr cnt1
work_C3:
;сбросим флаг переноса
	clc
;проверим надо ли при сдвиге внести значение переноса
	brtc PC+2
	sec
	clt
;проводим сдвиг
	rol tmp1
	brcc PC+2
;при необходимости запомним наличие переноса при последнем сдвиге
	set

	rcall Delay

;организуем паузу выполнения эффекта
	inc cnt1
	cpi cnt1,32
	breq work_C4_

;учитывая что у нас есть светодиоды
; как с общим анодом так и с общим катодом преобразуем выходной байт
	mov tmp2,tmp1
	ldi tmp3,0x0F
	eor tmp2,tmp3
	
	out PORTB,tmp2
	rjmp work_C3

work_C4_:
	ldi tmp1,0b01011010
	clr cnt1

	mov tmp2,tmp1
work_C4:
	
	rcall Delay

;организуем паузу выполнения эффекта
	inc cnt1
	cpi cnt1,32
	brne PC+2
	rjmp work_C1_

	ldi tmp3,0xFF
	eor tmp2,tmp3
	
	out PORTB,tmp2
	rjmp work_C4

;**************************************

;**************************************
; работа с семисегментным индикатором
; поочередно выводим все цифры с 0 по 99
; для работы с индикатором используем таблицу соответствия цифр-коду
; работа с двумя индикаторами
;
work_indBCD:
;-------------------------- Инициализация Порта ввода/вывода D

		ldi		r16, 0xFF	; Записываем число $FF в регистр r16
		out		DDRD, r16	; Записываем это число в DDRD
		ldi		r16, 0x00	; Записываем число $00 в регистр r16
		out		PORTD, r16	; Записываем то  же число в PORTD
; проинициализировали порт D на вывод и погасили все светики для индикатора с общим катодом
	ldi tmp1,-1
work_BCD:
	inc tmp1
	cpi tmp1,16
	brne normBCD
	clr tmp1
normBCD:
	out PORTD,tmp1
	rcall DelayLong
	
	rjmp work_BCD
;**************************************

;**************************************
; работа с семисегментным индикатором
; поочередно выводим все цифры с 0 по 99
; для работы с индикатором используем таблицу соответствия цифр-коду
; работа с двумя индикаторами
;
work_indicator2:
;-------------------------- Инициализация Порта ввода/вывода B

		ldi		r16, 0xFF	; Записываем число $FF в регистр r16
		out		DDRB, r16	; Записываем это число в DDRB
		ldi		r16, 0x00	; Записываем число $00 в регистр r16
		out		PORTB, r16	; Записываем то  же число в PORTB
; проинициализировали порт В на вывод и погасили все светики для индикатора с общим катодом

;-------------------------- Инициализация Порта ввода/вывода D

		ldi		r16, 0xC0	; Записываем число $С0 или 0b11000000 в регистр r16
		out		DDRD, r16	; Записываем это число в DDRD
		ldi		r16, 0x00	; Записываем число $00 в регистр r16
		out		PORTD, r16	; Записываем то  же число в PORTD
; проинициализировали порт D для контроля индикатор(когда гореть и какой цифре из двух)

; теперь организуем бесконечный цикл для вывода всех цифр
	ldi tmp1,-1
	clr tmpH2
work_ind2:
	inc tmp1
	mov tmpL2,tmp1	
	cpi tmpL2,100
	brne normal2
	clr tmp1
normal2:
; проведем выбор кода для соответствующей цифры
		ldi tmpL, low(10)
		ldi tmpH, high(10)
		rcall digit

; организуем вывод десятков
	out PORTB, r0
; для того чтоб цифра отобразилась на индикаторе необходимо зажечь её
	sbi PORTD, PD7

		mov cnt1, tmpL2
		rcall number_init

	rcall DelayLong
	cbi PORTD, PD7

; организуем вывод единиц
	out PORTB, r0
; для того чтоб цифра отобразилась на индикаторе необходимо зажечь её
	sbi PORTD, PD6

	rcall DelayLong
	cbi PORTD, PD6

	rjmp work_ind2
;**************************************

;**************************************
; работа с семисегментным индикатором
; поочередно выводим все цифры с 0 по 9
; для работы с индикатором используем таблицу соответствия цифр-коду
; работа только с одним индикатором
;
;
work_indicator:
;-------------------------- Инициализация Порта ввода/вывода B

		ldi		r16, 0xFF	; Записываем число $FF в регистр r16
		out		DDRB, r16	; Записываем это число в DDRB
		ldi		r16, 0x00	; Записываем число $00 в регистр r16
		out		PORTB, r16	; Записываем то  же число в PORTB
; проинициализировали порт В на вывод и погасили все светики для индикатора с общим катодом

;-------------------------- Инициализация Порта ввода/вывода D

		ldi		r16, 0xC0	; Записываем число $С0 или 0b11000000 в регистр r16
		out		DDRD, r16	; Записываем это число в DDRD
		ldi		r16, 0x00	; Записываем число $00 в регистр r16
		out		PORTD, r16	; Записываем то  же число в PORTD
; проинициализировали порт D для контроля индикатор(когда гореть и какой цифре из двух)

; теперь организуем бесконечный цикл для вывода всех цифр
	ldi r17,-1
work_ind:
	inc r17	
	cpi r17,10
	brne normal
	clr r17
normal:
; проведем выбор кода для соответствующей цифры
	LDI ZH,High(2*TableIndicator)
	LDI ZL,Low(2*TableIndicator)
	add ZL,r17
	clr r18
	adc ZH, r18
	lpm r18,Z

	out PORTB, r18
; для того чтоб цифра отобразилась на индикаторе необходимо зажечь её
	sbi PORTD, PD7

	rcall DelayLong
	cbi PORTD, PD7

	rjmp work_ind
;**************************************


;**************************************
; тест МК для точной подстройки частоты
; организуем меандр в 20 тактов
; 10 тактов высокий уровень
; 10 тактов низкий уровень
test_main:
	cli
	ldi r16, 0xFF
	out DDRB, r16
	out PORTB, r16
	nop
	nop
	nop
	nop
	nop
	nop
	ldi r16, 0xFF
	out DDRB, r16
	clr r16
	out PORTB, r16
	nop
	nop
	nop
	nop
		rjmp test_main
;**************************************
