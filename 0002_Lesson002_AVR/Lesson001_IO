;**************************************
;** Компьютерный центр FLASH
;** Компьютерная грамота в Харцызске
;** г. Харцызск, пер. Шмидта, 2
;**
;**(здание ООО "Данко" - бывшая книжная база, рядом ГорГАИ, ОШ №7, "Танк")
;**
;** Менеджер по работе с клиентами Павел
;**
;** mob: 095-725-20-14
;**
;** mob: 099-490-69-45
;**
;** mail: info@imkoteh.com
;**************************************
;**************************************
;**	Интернет-магазин "ИМКОТЕХ"
;** Компьютерная техника в Харцызске
;** г. Харцызск, пер. Шмидта, 2
;**
;**(здание ООО "Данко" - бывшая книжная база, рядом ГорГАИ, ОШ №7, "Танк")
;**
;** Менеджер по работе с клиентами Александр
;**
;** mob: 066-817-76-78
;**
;** mob: 050-044-79-69
;**
;** icq: 419-543-015
;**
;** mail: info@imkoteh.com
;**************************************


;**************************************
;**	Test Programm Version 001
;**	12 Jan 2013
;** Test List for Study
;**	Mega8	1MHz
;** Blackveolet
;** Ukraine, Donetsk region, Khartsyzsk
;** blackveolet@mail.ru
;**************************************

;**************************************
; Lesson 001 IO system
;**************************************
.nolist
; подключение библиотечных файлов
#include"m8def.inc"
.list
; Директива DEVICE позволяет указать для какого устройства компилируется программа.
; При использовании данной директивы компилятор выдаст предупреждение, если будет 
; найдена инструкция, которую не поддерживает данный микроконтроллер. Также будет выдано
; предупреждение, если программный сегмент, либо сегмент EEPROM превысят размер допускаемый устройством. 
; Если же директива не используется то все инструкции считаются допустимыми, и отсутствуют ограничения на размер сегментов.
.device ATmega8


; описание вектора прерываний

; выбор сегмента памяти программ
.cseg
; Reset Handler
.org 0x000 rjmp RESET ; Reset Handler
; IRQ0 Handler
.org 0x001 reti;rjmp EXT_INT0 ; IRQ0 Handler
; IRQ1 Handler
.org 0x002 reti;rjmp EXT_INT1 ; IRQ1 Handler
; Timer2 Compare Handler
.org 0x003 reti;rjmp TIM2_COMP ; Timer2 Compare Handler
; Timer2 Overflow Handler
.org 0x004 reti;rjmp TIM2_OVF ; Timer2 Overflow Handler
; Timer1 Capture Handler
.org 0x005 reti;rjmp TIM1_CAPT ; Timer1 Capture Handler
; Timer1 CompareA Handler
.org 0x006 reti;rjmp TIM1_COMPA ; Timer1 CompareA Handler
; Timer1 CompareB Handler
.org 0x007 reti;rjmp TIM1_COMPB ; Timer1 CompareB Handler
; Timer1 Overflow Handler
.org 0x008 reti;rjmp TIM1_OVF ; Timer1 Overflow Handler
; Timer0 Overflow Handler
.org 0x009 reti;rjmp TIM0_OVF ; Timer0 Overflow Handler
; SPI Transfer Complete Handler
.org 0x00a reti;rjmp SPI_STC ; SPI Transfer Complete Handler
; USART RX Complete Handler
.org 0x00b reti;rjmp USART_RXC ; USART RX Complete Handler
; UDR Empty Handler
.org 0x00c reti;rjmp USART_UDRE ; UDR Empty Handler
; USART TX Complete Handler
.org 0x00d reti;rjmp USART_TXC ; USART TX Complete Handler
; ADC Conversion Complete Handler
.org 0x00e reti;rjmp ADC ; ADC Conversion Complete Handler
; EEPROM Ready Handler
.org 0x00f reti;rjmp EE_RDY ; EEPROM Ready Handler
; Analog Comparator Handler
.org 0x010 reti;rjmp ANA_COMP ; Analog Comparator Handler
; Two-wire Serial Interface Handler
.org 0x011 reti;rjmp TWSI ; Two-wire Serial Interface Handler
; Store Program Memory Ready Handler
.org 0x012 reti;rjmp SPM_RDY ; Store Program Memory Ready Handler


;описание всех РОНов
.def tmpL	= r16	;главный рабочий регистр(младший)
.def tmpH	= r17	;главный рабочий регистр(старший)
.def tmpL2	= r18	;вспомогательный рабочий регистр(младший)
.def tmpH2	= r19	;вспомогательный рабочий регистр(старший)
.def tmp1	= r20	;пользовательский 1 регистр
.def tmp2	= r21	;пользовательский 1 регистр
.def tmp3	= r22	;пользовательский 1 регистр
.def DataL	= r23	;регистр данных(младший)
.def DataH	= r24	;регистр данных(старший)
.def cnt1	= r25	;главный счетчик регистр
.def Flags	= r26	;регистр флагов

// организуем подключение всех файлов проекта
#include"DSEG.inc"		;файл резервирования переменных в ОЗУ и инициализация констант и таблиц
#include"EEPROM.inc"	;файл работы с энергонезависимой памятью
#include"RESET.inc" 	;файл инициализации(сброса)
#include"EXT_INT.inc"	;файл обработки внешних прерываний
#include"TIM0.inc"		;файл работы с Таймером0
#include"ANA_COMP.inc"	;файл работы с Аналоговым компоратором
#include"Delay.inc"		;файл организации задержек
#include"SubRouters.inc"

//организуем бесконечный цикл
main:	
; тут распологаем все команды нашей программы	


;********
;	rjmp test_main
;********
;	rjmp work_indicator
;********
;	ldi r19,0
;	rcall delay
;********
;	rcall DelaySmall
;********
;	rjmp work_indicator2
;********
;	rjmp work_indBCD
;********
;	rjmp work_Color
;********
;	rjmp work_Keyboard
;********
	rjmp work_Button
;********
;	rjmp work_ButINT
;********

	rjmp main


;**************************************
; работа с клавиатурой
; реализуем динамический опрос клавиатуры
;
work_Button:
;-------------------------- Инициализация Порта ввода/вывода B

		ldi		r16, 0xFF	; Записываем число $FF в регистр r16
		out		DDRB, r16	; Записываем это число в DDRB
		ldi		r16, 0xF0	; Записываем число $F0 в регистр r16
		out		PORTB, r16	; Записываем то  же число в PORTB
; проинициализировали порт B на вывод 

;-------------------------- Инициализация Порта ввода/вывода D

		ldi		r16, 0x07	; Записываем число $07 в регистр r16
		out		DDRD, r16	; Записываем это число в DDRD
		ldi		r16, 0x00	; Записываем число $F0 в регистр r16
		out		PORTD, r16	; Записываем то  же число в PORTD
; проинициализировали порт D на вывод 0..2 и на ввод 3..7 
; зажгем линии клавиатуры
	in	tmp1,PORTD 
	ori	tmp1,0x07


	rjmp work_Button
;**************************************
; работа с клавиатурой
; реализуем динамический опрос клавиатуры
;
work_KeyBoard:
;-------------------------- Инициализация Порта ввода/вывода B

		ldi		r16, 0xFF	; Записываем число $FF в регистр r16
		out		DDRB, r16	; Записываем это число в DDRB
		ldi		r16, 0xF0	; Записываем число $F0 в регистр r16
		out		PORTB, r16	; Записываем то  же число в PORTB
; проинициализировали порт B на вывод 

;-------------------------- Инициализация Порта ввода/вывода D

		ldi		r16, 0x07	; Записываем число $07 в регистр r16
		out		DDRD, r16	; Записываем это число в DDRD
		ldi		r16, 0x00	; Записываем число $F0 в регистр r16
		out		PORTD, r16	; Записываем то  же число в PORTD
; проинициализировали порт D на вывод 0..2 и на ввод 3..7 
Start_Key:
; зажгем линии клавиатуры
	in	tmp1,PORTD 
	ori	tmp1,0x07
	out PORTD,tmp1
;считаем, нажата ли хоть одна клавиша
	in tmp1,PIND
	andi tmp1,0b01111000
;	cpi tmp1,0
	breq Start_Key; ждем нажатия кнопки
; для борьбы с дребезгом 
; будем считывать кнопки пока не считаем 16 раз одну и ту же комбинацию
	clr tmp2
	ldi cnt1,16
Line1:	
; смотрим линию 1 цифры 1 4 7 *
	ldi tmp3,0
	cbi PORTD,PD1
	cbi PORTD,PD2
; если нашли на линии 1 кнопку идем ее определять
	in tmp1,PIND
	andi tmp1,0b01111000
;	cpi tmp1,0
	breq Line2
	rjmp find_key
Line2:
; смотрим линию 2 цифры 2 5 8 0
	ldi tmp3,1
	cbi PORTD,PD0
	sbi PORTD,PD1
; если нашли на линии 2 кнопку идем ее определять
	in tmp1,PIND
	andi tmp1,0b01111000
;	cpi tmp1,0
	breq Line3
	rjmp find_key
Line3:
; смотрим линию 3 цифры 3 6 9 №
	ldi tmp3,2
	cbi PORTD,PD1
	sbi PORTD,PD2
; если нашли на линии 3 кнопку идем ее определять
	in tmp1,PIND
	andi tmp1,0b01111000
;	cpi tmp1,0
	breq Start_Key

find_key:
; идея такая что проверяя все линии
; находим их вес
; если вес в текущем и предыдущем цикле опроса 
; совпадает, то это та кнопка что нужна
; в противном случае у нас дребезг
;
; приоритет у самой последней линии 
; при нажатии нескольких кнопок
; определим ту что ниже находится
	mov tmp2,tmp1

	sbic PIND,PD3
	ldi tmp1,1
	sbic PIND,PD4
	ldi tmp1,4
	sbic PIND,PD5
	ldi tmp1,7
	sbic PIND,PD6
	ldi tmp1,10
	
	cp tmp2,tmp1
	brne find_key

	dec cnt1
	brne find_key

; суммируем состовляющие кода нашей кнопки
	add tmp2,tmp3
; преобразуем регистр для вывода
	ldi tmp3,0x0F
	eor tmp2,tmp3

	out PORTB, tmp2

	rjmp Start_Key
;**************************************

;**************************************
; работа с линейкой светодиодо
; реализуем несколько световых эффектов
; например
;C1	бегущая светик по кругу
;C2	бегущий светик из стороны в сторону
;C3	два последовательных светика
;C4	горит каждый второй
;
work_Color:
;-------------------------- Инициализация Порта ввода/вывода B

		ldi		r16, 0xFF	; Записываем число $FF в регистр r16
		out		DDRB, r16	; Записываем это число в DDRB
		ldi		r16, 0xF0	; Записываем число $F0 в регистр r16
		out		PORTB, r16	; Записываем то  же число в PORTB
; проинициализировали порт B на вывод 
; и погасили все светики с общим катодом(младшая тетрада)
; и с общим анодом (старшая тетрада)
work_C1_:
	ldi tmp1,0b00000001
	clr cnt1
work_C1:
;сбросим флаг переноса
	clc
;проверим надо ли при сдвиге внести значение переноса
	brtc PC+2
	sec
	clt
;проводим сдвиг
	rol tmp1
	brcc PC+2
;при необходимости запомним наличие переноса при последнем сдвиге
	set

	rcall Delay

;организуем паузу выполнения эффекта
	inc cnt1
	cpi cnt1,32
	breq work_C2_

;учитывая что у нас есть светодиоды
; как с общим анодом так и с общим катодом преобразуем выходной байт
	mov tmp2,tmp1
	ldi tmp3,0x0F
	eor tmp2,tmp3
	
	out PORTB,tmp2
	rjmp work_C1

work_C2_:
	ldi tmp1,0b00000001
	clr cnt1
work_C2:
;организуем проверку в какую сторону движемся
; для этого выставляем признак флаг Т
	cpi tmp1,0b10000000
	brne PC+2
	set
	cpi tmp1,0b00000001
	brne PC+2
	clt
	
;просмотрим в хранилище необходим ли нам бит переноса
	clc
	sbrc Flags,0
	sec
;организуем сдвиг
;смотрим флаг Т(направление)
	rol tmp1
	brtc PC+3
	ror tmp1
	ror tmp1
;запоминаем флаг переноса
	clr Flags
	brcc PC+2
	ldi Flags, 1	

	rcall Delay

	inc cnt1
	cpi cnt1,64
	breq work_C3_

	mov tmp2,tmp1
	ldi tmp3,0xF0
	eor tmp2,tmp3

	out PORTB,tmp2
	rjmp work_C2

work_C3_:
	ldi tmp1,0b00000011
	clr cnt1
work_C3:
;сбросим флаг переноса
	clc
;проверим надо ли при сдвиге внести значение переноса
	brtc PC+2
	sec
	clt
;проводим сдвиг
	rol tmp1
	brcc PC+2
;при необходимости запомним наличие переноса при последнем сдвиге
	set

	rcall Delay

;организуем паузу выполнения эффекта
	inc cnt1
	cpi cnt1,32
	breq work_C4_

;учитывая что у нас есть светодиоды
; как с общим анодом так и с общим катодом преобразуем выходной байт
	mov tmp2,tmp1
	ldi tmp3,0x0F
	eor tmp2,tmp3
	
	out PORTB,tmp2
	rjmp work_C3

work_C4_:
	ldi tmp1,0b01011010
	clr cnt1

	mov tmp2,tmp1
work_C4:
	
	rcall Delay

;организуем паузу выполнения эффекта
	inc cnt1
	cpi cnt1,32
	brne PC+2
	rjmp work_C1_

	ldi tmp3,0xFF
	eor tmp2,tmp3
	
	out PORTB,tmp2
	rjmp work_C4

;**************************************

;**************************************
; работа с семисегментным индикатором
; поочередно выводим все цифры с 0 по 99
; для работы с индикатором используем таблицу соответствия цифр-коду
; работа с двумя индикаторами
;
work_indBCD:
;-------------------------- Инициализация Порта ввода/вывода D

		ldi		r16, 0xFF	; Записываем число $FF в регистр r16
		out		DDRD, r16	; Записываем это число в DDRD
		ldi		r16, 0x00	; Записываем число $00 в регистр r16
		out		PORTD, r16	; Записываем то  же число в PORTD
; проинициализировали порт D на вывод и погасили все светики для индикатора с общим катодом
	ldi tmp1,-1
work_BCD:
	inc tmp1
	cpi tmp1,16
	brne normBCD
	clr tmp1
normBCD:
	out PORTD,tmp1
	rcall DelayLong
	
	rjmp work_BCD
;**************************************

;**************************************
; работа с семисегментным индикатором
; поочередно выводим все цифры с 0 по 99
; для работы с индикатором используем таблицу соответствия цифр-коду
; работа с двумя индикаторами
;
work_indicator2:
;-------------------------- Инициализация Порта ввода/вывода B

		ldi		r16, 0xFF	; Записываем число $FF в регистр r16
		out		DDRB, r16	; Записываем это число в DDRB
		ldi		r16, 0x00	; Записываем число $00 в регистр r16
		out		PORTB, r16	; Записываем то  же число в PORTB
; проинициализировали порт В на вывод и погасили все светики для индикатора с общим катодом

;-------------------------- Инициализация Порта ввода/вывода D

		ldi		r16, 0xC0	; Записываем число $С0 или 0b11000000 в регистр r16
		out		DDRD, r16	; Записываем это число в DDRD
		ldi		r16, 0x00	; Записываем число $00 в регистр r16
		out		PORTD, r16	; Записываем то  же число в PORTD
; проинициализировали порт D для контроля индикатор(когда гореть и какой цифре из двух)

; теперь организуем бесконечный цикл для вывода всех цифр
	ldi tmp1,-1
	clr tmpH2
work_ind2:
	inc tmp1
	mov tmpL2,tmp1	
	cpi tmpL2,100
	brne normal2
	clr tmp1
normal2:
; проведем выбор кода для соответствующей цифры
		ldi tmpL, low(10)
		ldi tmpH, high(10)
		rcall digit

; организуем вывод десятков
	out PORTB, r0
; для того чтоб цифра отобразилась на индикаторе необходимо зажечь её
	sbi PORTD, PD7

		mov cnt1, tmpL2
		rcall number_init

	rcall DelayLong
	cbi PORTD, PD7

; организуем вывод единиц
	out PORTB, r0
; для того чтоб цифра отобразилась на индикаторе необходимо зажечь её
	sbi PORTD, PD6

	rcall DelayLong
	cbi PORTD, PD6

	rjmp work_ind2
;**************************************

;**************************************
; работа с семисегментным индикатором
; поочередно выводим все цифры с 0 по 9
; для работы с индикатором используем таблицу соответствия цифр-коду
; работа только с одним индикатором
;
;
work_indicator:
;-------------------------- Инициализация Порта ввода/вывода B

		ldi		r16, 0xFF	; Записываем число $FF в регистр r16
		out		DDRB, r16	; Записываем это число в DDRB
		ldi		r16, 0x00	; Записываем число $00 в регистр r16
		out		PORTB, r16	; Записываем то  же число в PORTB
; проинициализировали порт В на вывод и погасили все светики для индикатора с общим катодом

;-------------------------- Инициализация Порта ввода/вывода D

		ldi		r16, 0xC0	; Записываем число $С0 или 0b11000000 в регистр r16
		out		DDRD, r16	; Записываем это число в DDRD
		ldi		r16, 0x00	; Записываем число $00 в регистр r16
		out		PORTD, r16	; Записываем то  же число в PORTD
; проинициализировали порт D для контроля индикатор(когда гореть и какой цифре из двух)

; теперь организуем бесконечный цикл для вывода всех цифр
	ldi r17,-1
work_ind:
	inc r17	
	cpi r17,10
	brne normal
	clr r17
normal:
; проведем выбор кода для соответствующей цифры
	LDI ZH,High(2*TableIndicator)
	LDI ZL,Low(2*TableIndicator)
	add ZL,r17
	clr r18
	adc ZH, r18
	lpm r18,Z

	out PORTB, r18
; для того чтоб цифра отобразилась на индикаторе необходимо зажечь её
	sbi PORTD, PD7

	rcall DelayLong
	cbi PORTD, PD7

	rjmp work_ind
;**************************************


;**************************************
; тест МК для точной подстройки частоты
; организуем меандр в 20 тактов
; 10 тактов высокий уровень
; 10 тактов низкий уровень
test_main:
	cli
	ldi r16, 0xFF
	out DDRB, r16
	out PORTB, r16
	nop
	nop
	nop
	nop
	nop
	nop
	ldi r16, 0xFF
	out DDRB, r16
	clr r16
	out PORTB, r16
	nop
	nop
	nop
	nop
		rjmp test_main
;**************************************
